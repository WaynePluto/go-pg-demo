
# **身份与访问控制 (IACC) 模块设计方案**

以下是基于您提供的 `Identity & Access Control Context` 领域模型的设计方案。

#### 1. 对外 API 设计

根据 `api路径规范`，API 路径将使用单数名词，并为批量操作使用特定前缀。

**认证 API**
*   `POST /api/v1/login`：用户登录，成功后返回 JWT。

**用户 (User) 管理 API**
*   `POST /api/v1/user`：创建新用户。
*   `GET /api/v1/user/{id}`：获取指定用户的详细信息（包含个人资料和角色）。
*   `PUT /api/v1/user/{id}`：更新用户的个人资料（如 `fullName`, `department`）。
*   `GET /api/v1/user/list`：获取用户列表（支持分页、按用户名/状态/手机号搜索）。
*   `PUT /api/v1/user/{id}/status`：更新用户状态（激活/禁用）。
*   `PUT /api/v1/user/{id}/password`：修改用户密码（此接口为管理员或用户自己操作，需要权限控制）。
*   `POST /api/v1/user/{id}/role/batch-assign`：为用户批量分配角色。
*   `GET /api/v1/user/{id}/permission`：获取用户的最终有效权限集。

**角色 (Role) 管理 API**
*   `POST /api/v1/role`：创建新角色。
*   `GET /api/v1/role/{id}`：获取指定角色的详细信息（包含权限列表）。
*   `PUT /api/v1/role/{id}`：更新角色信息（如名称、描述）。
*   `DELETE /api/v1/role/{id}`：删除角色。
*   `GET /api/v1/role/list`：获取角色列表（支持分页、按名称搜索）。
*   `PUT /api/v1/role/{id}/permission/batch-assign`：为角色批量分配权限。

**权限 (Permission) API**
*   `GET /api/v1/permission/list`：获取系统中所有预定义的权限键列表，用于前端展示。


#### 2. 数据库表设计

根据 `数据库建模规范`，表名使用单数，并为领域内的表添加缩写前缀 `iacc_` (Identity Access Control Context)。

1.  **用户表 (iacc_user)**
    *   `id` (BIGINT, PK, Auto-increment)
    *   `username` (VARCHAR, Unique) - 用户名
    *   `phone` (VARCHAR, Unique) - 手机号
    *   `password` (VARCHAR) - 存储前端传递的 MD5 密文
    *   `status` (TINYINT) - 用户状态 (例如: 1=Active, 2=Inactive)
    *   `created_at` (TIMESTAMP)
    *   `updated_at` (TIMESTAMP)

2.  **用户资料表 (iacc_profile)**
    *   `user_id` (BIGINT, PK, FK to `iacc_user.id`)
    *   `full_name` (VARCHAR) - 姓名
    *   `department` (VARCHAR) - 部门
    *   `created_at` (TIMESTAMP)
    *   `updated_at` (TIMESTAMP)

3.  **角色表 (iacc_role)**
    *   `id` (BIGINT, PK, Auto-increment)
    *   `name` (VARCHAR, Unique) - 角色名称
    *   `description` (VARCHAR) - 角色描述
    *   `created_at` (TIMESTAMP)
    *   `updated_at` (TIMESTAMP)

4.  **用户角色关联表 (iacc_user_role)**
    *   `user_id` (BIGINT, PK, FK to `iacc_user.id`)
    *   `role_id` (BIGINT, PK, FK to `iacc_role.id`)

5.  **角色权限关联表 (iacc_role_permission)**
    *   `role_id` (BIGINT, PK, FK to `iacc_role.id`)
    *   `permission_key` (VARCHAR, PK) - 权限标识符

---

#### 3. Module 目录结构设计

根据 `扩展新业务规范`，新的业务模块将在 modules 下创建。

```
internal/modules/
└── iacc/               # 身份与访问控制模块根目录
    ├── user/           # 用户实体相关
    │   ├── handler.go
    │   ├── handler_test.go
    │   ├── routes.go
    │   └── type.go
    ├── role/           # 角色实体相关
    │   ├── handler.go
    │   ├── handler_test.go
    │   ├── routes.go
    │   └── type.go
    ├── permission/     # 权限相关
    │   ├── handler.go
    │   ├── routes.go
    │   └── type.go
    └── service/        # 跨实体业务逻辑
        └── permission_service.go
```

*   **`iacc/user/`**: 负责用户聚合根的所有操作。
*   **`iacc/role/`**: 负责角色聚合根的所有操作。
*   **`iacc/permission/`**: 负责权限常量列表的查询。
*   **`iacc/service/permission_service.go`**: 实现 `PermissionCalculationService` 领域服务，负责计算用户的有效权限。

---

#### 4. 是否需要扩展新的中间件

**是**，需要一个用于 **权限校验** 的新中间件。

*   **名称**: `CheckPermission`
*   **位置**: `internal/middlewares/permission.go`
*   **逻辑**:
    1.  从 JWT 中解析出 `userId`。
    2.  调用 `iacc/service/permission_service.go` 中的函数，计算该用户的有效权限集。
    3.  从路由注册中获取当前 API 所需的权限 `permissionKey`。
    4.  检查用户的权限集是否包含所需的 `permissionKey`。
    5.  若不包含，则返回 `403 Forbidden` 错误。
*   **应用方式**: 在 `iacc` 模块各个 `routes.go` 文件中，按需注册到需要权限控制的路由上。

---

#### 5. 是否需要扩展新的 pkgs 组件

**是**，至少需要一个用于 **权限常量定义** 的新组件。

*   **名称**: `permission`
*   **位置**: `internal/pkgs/permission/`
*   **文件**: `internal/pkgs/permission/keys.go`
*   **内容**:
    *   定义一个 `PermissionKey` 的自定义类型（`type PermissionKey string`）。
    *   以常量形式（`const`）定义所有业务所需的权限键，例如：
        ```go
        package permission

        type Key string

        const (
            UserCreate   Key = "user:create"
            UserView     Key = "user:view"
            UserEdit     Key = "user:edit"
            RoleCreate   Key = "role:create"
            // ... 其他权限
        )

        // 提供一个函数返回所有权限的列表
        func AllKeys() []Key {
            return []Key{UserCreate, UserView, UserEdit, RoleCreate, ...}
        }
        ```
*   **优点**: 遵循领域模型中关于权限常量化的建议，提供类型安全、易于发现和重构的权限管理方式。